# 性能监控

### 1.线下


#### 1.1 Instruments

* 关于线下性能监控，苹果公司官方就有一个性能监控工具 Instruments。它是一款被集成在 Xcode 里，专门用来在线下进行性能分析的工具

#### 1.2 功能

* Instruments 的功能非常强大，比如说 Energy Log 就是用来监控耗电量的，Leaks 就是专门用来监控内存泄露问题的，Network 就是用来专门检查网络情况的，Time Profiler 就是通过时间采样来分析页面卡顿问题的

![087ddcf91e5c222804f753389edf2de9](https://user-images.githubusercontent.com/17693976/211303095-1ab88055-406b-475a-bc4c-13608d9ccce9.png)

#### 1.3 优势（Instruments 10 以后）

* Instruments 基于 os_signpost 架构，可以支持所有平台
* Instruments 由于标准界面（Standard UI）和分析核心（Analysis Core）技术，使得我们可以非常方便地进行自定义性能监测工具的开发。给 Instruments 内置的工具换个交互界面或新创建一个工具的时，都可以通过自定义工具这个功能来实现

#### 1.4 开发一款自定义 Instruments 工具，主要步骤：

* 在 Xcode 中，点击 File > New > Project
* 在弹出的 Project 模板选择界面，将其设置为 macOS
* 选择 Instruments Package，点击后即可开始自定义工具的开发了
* 经过上面的三步之后，会在新创建的工程里面生成一个.instrpkg 文件，接下来的开发过程主要就是对这个文件的配置工作了。主要是完成 Standard UI 和 Analysis Core 的配置
* 苹果公司还提供了大量的代码片段，帮助你进行 [个性化配置](https://help.apple.com/instruments/developer/mac/current/)

![e51d838fda0c79ff0a48566ec87305be](https://user-images.githubusercontent.com/17693976/211303851-61742fcb-957d-4e1c-9648-3fb571531bbd.png)

#### 1.5 Analysis Core 收集和处理数据的过程

* 1. 处理我们配置好的各种数据表，并申请存储空间 store
* 2. store 去找数据提供者，如果不能直接找到，就会通过 Modeler 接收其他 store 的输入信号进行合成
* 3. store 获得数据源后，会进行 Binding Solution 工作来优化数据处理过程

**在我们通过 store 找到的这些数据提供者中，对开发者来说最重要的就是 os_signpost。os_signpost 的主要作用，是让你可以在程序中通过编写代码来获取数据。你可以在工程中的任何地方通过 os_signpost API ，将需要的数据提供给 Analysis Core**

#### 1.5.1 范例

* 苹果公司在 WWDC 2018 Session 410 [Creating Custom Instruments](https://developer.apple.com/videos/play/wwdc2018/410) 里提供了一个范例：通过 os_signpost API 将图片下载的数据提供给 Analysis Core 进行监控观察。这个示例在 App 的代码如下所示：

```

os_signpost(.begin, log: parsinglog, name:"Parsing", "Parsing started SIZE:%ld", data.count)
// Decode the JSON we just downloaded
let result = try jsonDecoder.decode(Trail.self, from: data)
os_signpost(.end, log: parsingLog, name:"Parsing", "Parsing finished")

```

* 注意 os_signpost 的 begin 和 end 需要成对出现

#### 1.6 配置

* Instruments 通过配置数据表来使用这些数据的。配置的数据表的 XML 设计如下所示：

```
<os-signpost-interval-schema>
<id>json-parse</id>
<title>Image Download</title>
<subsystem>"com.apple.trailblazer</subsystem>
<category>"Networking</category>
<name>"Parsing"</name>
<start-pattern>
<message>"Parsing started SIZE:" ?data-size</message> 
</start-pattern>
<column>
<mnemonic>data-size</mnemonic>
<title>JSON Data Size</title>
<type>size-in-bytes</type>
<expression>?data-size</expression>
</column>
</os-signpost-interval-schema>
```

* 配置数据表是要对数据输出进行可视化配置，从而可以将代码中的数据展示出来，如下图所示，就是对下载图片大小监控的效果

![cdf512c900bac905b21d28202386b8b2](https://user-images.githubusercontent.com/17693976/211306795-2bbf2f91-149e-4e0a-958d-901af0a13c54.png)


### 2. 线上


#### 2.1 CPU 使用率

* App 作为进程运行起来后会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU 使用率的总和，就是当前 App 对 CPU 的使用率
* 线程基本信息的结构体是 thread_basic_info_t，这个结构体里就包含了我们需要的 CPU 使用率的字段 cpu_usage。累加这个字段就能够获取到当前的整体 CPU 使用率

#### 2.2 FPS

* 通过注册 CADisplayLink 得到屏幕的同步刷新率，记录每次刷新时间，然后就可以得到 FPS

#### 2.3 内存使用量

* 在获取 iOS 应用内存使用量时，都是使用 task_basic_info 里的 resident_size 字段信息。以此获得的内存使用量和 Instruments 里看到的相差很大
* 在 2018 WWDC Session 416 [iOS Memory Deep Dive](https://developer.apple.com/videos/play/wwdc2018/416/) 中，苹果公司介绍说 phys_footprint 才是实际使用的物理内存

#### 2.3.1 task_vm_info

* 内存信息存在 task_info.h 文件的 task_vm_info 结构体中

```

struct task_vm_info {
  mach_vm_size_t  virtual_size;       // 虚拟内存大小
  integer_t region_count;             // 内存区域的数量
  integer_t page_size;
  mach_vm_size_t  resident_size;      // 驻留内存大小
  mach_vm_size_t  resident_size_peak; // 驻留内存峰值

  ...

  /* added for rev1 */
  mach_vm_size_t  phys_footprint;     // 物理内存

  ...
```
