# 二.启动优化与监控

### 1. 三个阶段

* 1. main() 函数执行前；main() 
* 2. 函数执行后；
* 3. 首屏渲染完成后。

### 2 main() 函数执行前

#### 2.1 做了哪些

* 加载可执行文件（App 的.o 文件的集合）；
* 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定；
* Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等；
* 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。

#### 2.2 优化方案

* 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司建议最多使用 6 个非系统动态库。
* 减少加载启动后不会去使用的类或者方法。
* +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。
* 控制 C++ 全局变量的数量。


### 3. main() 函数执行后


#### 3.1 做了哪些

* 首屏初始化所需配置文件的读写操作；
* 首屏列表大数据的读取；
* 首屏渲染的大量计算等。

#### 3.2 优化方案

> 很多时候，开发者会把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。更加优化的开发方式，应该是从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行。


### 4. 首屏渲染完成后

> 这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作

### 5. 功能级别的启动优化

> 功能级别的启动优化，就是要从 main() 函数执行后这个阶段下手。
> 优化的思路是： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做

### 6. 方法级别的启动优化

#### 6.1 定时抓取主线程上的方法调用堆栈

> Time Profiler 使用的就是这种方式

##### 6.1.1 定时间隔

> 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确
> 定时间隔如果小于所有方法执行的时间（比如 0.002 秒），基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样对整体耗时的影响小，不过很多方法耗时就不精确了

#### 6.2 hook objc_msgSend（fishhook）

> hook objc_msgSend 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。
> 对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高。

