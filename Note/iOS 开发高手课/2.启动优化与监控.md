# 2.启动优化与监控


### 一. 三个阶段

* 1. main() 函数执行前
* 2. main() 函数执行后
* 3. 首屏渲染完成后

### 二. main() 函数执行前

#### 2.1 做了哪些

* 加载可执行文件（.o 文件）
* 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定
* Objc 运行时的初始处理，类注册、category 注册、selector 唯一性检查等
* 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量

#### 2.2 优化方案

* 减少动态库加载。可进行进行合并。苹果建议最多使用 6 个非系统动态库
* 减少加载启动后不会去使用的类或者方法
* +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，一个 +load() 会有 4 毫秒的消耗
* 控制 C++ 全局变量的数量


### 3. main() 函数执行后

#### 3.1 做了哪些

* 首屏初始化所需配置文件的读写操作；
* 首屏列表大数据的读取；
* 首屏渲染的大量计算等。

#### 3.2 优化方案

* 功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些使用时才需要初始化。
* 梳理完之后，将这些初始化功能分别放到合适的阶段进行。


### 4. 首屏渲染完成后

* 用户已经能看到首页信息。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作

### 5. 功能级别的启动优化

* 从 main() 函数执行后这个阶段下手
* main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务
* 非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去执行

### 6. 方法级别的启动优化

#### 6.1 定时抓取主线程上的方法调用堆栈

* Time Profiler 使用的就是这种方式

##### 6.1.1 定时间隔

* 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确
* 定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确
* 定时间隔如果小于所有方法执行的时间（比如 0.002 秒），基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样对整体耗时的影响小，不过很多方法耗时就不精确了

#### 6.2 hook objc_msgSend（fishhook）

* 缺点是只能针对 Objective-C 的方法
* 对于 c 方法和 block 可以使用 libffi 的 ffi_call，缺点是编写维护相关工具门槛高

