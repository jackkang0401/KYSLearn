# 崩溃


### 1.常见崩溃

* 数组越界：在取数据索引时越界，App 会发生崩溃
* 多线程问题：在子线程中进行 UI 更新可能会发生崩溃，多个线程进行数据的读取操作，因为处理时机不一致，可能会出现崩溃情况。
* 主线程无响应：如果主线程超过系统规定的时间无响应，就会被 Watchdog 杀掉。这时，崩溃问题对应的异常编码是 0x8badf00d
* 野指针：指针指向一个已删除的对象访问内存区域时，会出现野指针崩溃


### 2.可捕获的

* KVO 问题、NSNotification 线程问题、数组越界、野指针等崩溃信息
 
#### 2.1 原理

* 对各种信号都进行了注册，捕获到异常信号后，在处理方法 handleSignalException 里通过 backtrace_symbols 方法就能获取到当前的堆栈信息。堆栈信息可以先保存在本地，下次启动时再上传到崩溃监控服务器就可以了
 
#### 2.2 第三方库

* [PLCrashReporter](https://github.com/microsoft/plcrashreporter)

#### 2.3 三方平台

* [Bugly](https://bugly.qq.com/v2/)


### 3.捕获不到的

* 后台任务超时、内存被打爆、主线程卡顿超阈值等信息

#### 3.1 后台任务

* 使用 Background Mode 方式的话，App Store 在审核时会提高对 App 的要求。通常情况下，只有那些地图、音乐播放、VoIP 类的 App 才能通过审核
* Background Fetch 方式的唤醒时间不稳定，而且用户可以在系统里设置关闭这种方式，导致它的使用场景很少
* Silent Push 是推送的一种，会在后台唤起 App 30 秒。它的优先级很低，会调用 application:didReceiveRemoteNotifiacation:fetchCompletionHandler: 这个 delegate，和普通的 remote push notification 推送调用的 delegate 是一样的
* PushKit 后台唤醒 App 后能够保活 30 秒。它主要用于提升 VoIP 应用的体验
* Background Task 方式，是使用最多的。App 退后台后，默认都会使用这种方式

#### 3.2 Background Task（最多执行 3 分钟）

* 根据后台保活 3 分钟这个阈值，先设置一个计时器，在接近 3 分钟时，如果还在执行的话，我们就可以判断该程序即将后台崩溃，进行上报、记录，以达到监控的效果


#### 3.2 内存打爆 & 主线程卡顿时间超过阈值被 watchdog 杀掉

* 这两类崩溃的思路和监控后台崩溃类似，我们都先要找到它们的阈值，然后在临近阈值时还在执行的后台程序，判断为将要崩溃，收集信息并上报

### 4. 分析并解决崩溃问题

#### 4.1 崩溃日志

* 进程信息：崩溃进程的相关信息，比如崩溃报告唯一标识符、唯一键值、设备标识
* 基本信息：崩溃发生的日期、iOS 版本
* 异常信息：异常类型、异常编码、异常的线程
* 线程回溯：崩溃时的方法调用栈

#### 4.2 异常编码

* 0x8badf00d，表示 App 在一定时间内无响应而被 watchdog 杀掉的情况（包含主线程被卡）
* 0xdeadfa11，表示 App 被用户强制退出
* 0xc00010ff，表示 App 因为运行造成设备温度太高而被杀掉（要对每个线程 CPU 进行针对性的检查和优化）

### 5 小结

* 现有的崩溃监控系统，不管是开源的崩溃日志收集库还是类似 Bugly 的崩溃监控系统，离最优解都还有一定的距离
* 这个“非最优”，我们需要分两个维度来看：一个维度是，怎样才能够让崩溃信息的收集效率更高，丢失率更低；另一个维度是，如何能够收集到更多的崩溃信息，特别是系统强杀带来的崩溃
* 随着 iOS 系统的迭代更新，强杀阈值和强杀种类都在不断变化，因此崩溃监控系统也需要跟上系统迭代更新的节奏，同时还要做好向下兼容







