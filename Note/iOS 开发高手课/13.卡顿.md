# 卡顿


### 1.卡顿原因

* 复杂 UI 、图文混排的绘制量过大
* 在主线程上做网络同步请求
* 在主线程做大量的 IO 操作
* 运算量过大，CPU 持续高占用
* 死锁和主子线程抢锁


### 2.RunLoop

* 由 CFRunLoop 实现。简单来说，RunLoop 是用来监听输入源，进行调度处理的。输入源可以是输入设备、网络、周期性或者延迟时间、异步回调
* RunLoop 的目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠

#### 2.1 唤醒

* 基于 port 的 Source 事件
* Timer 时间到
* RunLoop 超时
* 被调用者唤醒

#### 2.2 六个状态

```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { 
    kCFRunLoopEntry ,         // 进入 loop 
    kCFRunLoopBeforeTimers ,  // 触发 Timer 回调 
    kCFRunLoopBeforeSources , // 触发 Source0 回调 
    kCFRunLoopBeforeWaiting , // 等待 mach_port 消息 
    kCFRunLoopAfterWaiting ), // 接收 mach_port 消息 
    kCFRunLoopExit ,          // 退出 loop 
    kCFRunLoopAllActivities   // loop 所有状态改变
}

```
