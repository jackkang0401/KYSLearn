# 日志监控


### 1. 获取 NSLog 的日志

* 输出信息到标准的 Error 控制台和系统日志（syslog）中

### 2. iOS 10 之前使用 ASL（Apple System Logger）

* 苹果公司自己实现的一套输出日志的接口）的 API，将日志消息直接存储在磁盘上

#### 2.1 捕获

* 在日志被保存到 ASL 的数据库时，syslogd（系统里用于接收分发日志消息的日志守护进程） 会发出一条通知
* notify_register_dispatch 的作用是用来注册进程间的系统通知。kNotifyASLDBUpdate 宏就是，日志被保存到 ASL 数据库时发出的跨进程通知，其键值是 com.apple.system.logger.message

### 3. iOS 10 之后，使用统一日志系统（Unified Logging System）

* 统一日志系统的方式，是把日志集中存放在内存和数据库里，并提供单一、高效和高性能的接口去获取系统所有级别的消息传递

#### 3.1 捕获

#### 3.1.1 重定向

* 需要对 NSLog 日志的输出进行重定向。因为 NSLog 本身就是一个 C 函数，而不是 Objective-C 方法，所以我们就可以使用 fishhook 来完成重定向的工作

```


static void (&orig_nslog)(NSString *format, ...);

void redirect_nslog(NSString *format, ...) {
    // 可以在这里先进行自己的处理
    
    // 继续执行原 NSLog
    va_list va;
    va_start(va, format);
    NSLogv(format, va);
    va_end(va);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        struct rebinding nslog_rebinding = {"NSLog",redirect_nslog,(void*)&orig_nslog};

        NSLog(@"try redirect nslog %@,%d",@"is that ok?");
    }
    return
}

```

> 利用了 fishhook 对方法的符号地址进行了重新绑定，从而只要是 NSLog 的调用就都会转向 redirect_nslog 方法调用。
> 在 redirect_nslog 方法中，你可以先进行自己的处理，比如将日志的输出重新输出到自己的持久化存储系统里，接着调用 NSLog 也会调用的 NSLogv 方法进行原 NSLog 方法的调用

#### 3.1.2 句柄

> NSLog 最后写文件时的句柄是 STDERR，我先前跟你说了苹果对于 NSLog 的定义是记录错误的信息，STDERR 的全称是 standard error，系统错误日志都会通过 STDERR 句柄来记录。
> 所以 NSLog 最终将错误日志进行写操作的时候也会使用 STDERR 句柄，而 dup2 函数是专门进行文件重定向的，那么也就有了另一个不使用 fishhook 还可以捕获 NSLog 日志的方法。
> 你可以使用 dup2 重定向 STDERR 句柄，使得重定向的位置可以由你来控制

```

int fd = open(path, (O_RDWR | O_CREAT), 0644);
dup2(fd, STDERR_FILENO);

```
* 其中，path 就是你自定义的重定向输出的文件地址


### 4. [CocoaLumberjack](https://github.com/CocoaLumberjack/CocoaLumberjack)



